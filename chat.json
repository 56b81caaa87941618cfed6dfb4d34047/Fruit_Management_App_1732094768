[
    {
        "id": "2580578b-a99b-41fc-9533-361b26116fb2",
        "timestamp": "2024-11-20T09:26:11.384677Z",
        "role": "assistant",
        "source": "base_assistant",
        "content": "Welcome to your new project! I can help you edit it however you want. What would you like to do?",
        "metadata": {}
    },
    {
        "id": "b6f228d9-b4b0-4720-8f3a-07ec932dfcf9",
        "timestamp": "2024-12-02T16:24:38.855634Z",
        "role": "user",
        "source": "web_client",
        "content": "generate this exact sc",
        "metadata": {}
    },
    {
        "id": "bd490781-f808-464c-8624-bbaf404f699d",
        "timestamp": "2024-12-02T16:24:42.044092Z",
        "role": "tool_call",
        "source": "base_assistant",
        "content": null,
        "metadata": {
            "id": "call_dp68VxR1kXyb5UgEKoa4z2W2",
            "function": {
                "arguments": "{}",
                "name": "TransferToSmartContractAssistant"
            },
            "type": "function"
        }
    },
    {
        "id": "fab83690-e3d3-47c3-96f5-e6207909c6ed",
        "timestamp": "2024-12-02T16:24:43.346979Z",
        "role": "tool_result",
        "source": "TransferToSmartContractAssistant",
        "content": "Conversation switched to smart_contract_assistant. Adopt the persona of smart_contract_assistant immediately.",
        "metadata": {
            "tool_call_id": "call_dp68VxR1kXyb5UgEKoa4z2W2"
        }
    },
    {
        "id": "c86c6152-ca73-4a00-8db6-dd423a927840",
        "timestamp": "2024-12-02T16:24:45.420273Z",
        "role": "assistant",
        "source": "smart_contract_assistant",
        "content": "Please provide the details or description of the smart contract you would like to generate.",
        "metadata": {}
    },
    {
        "id": "54c07005-9fc3-415c-8c26-317130c7427c",
        "timestamp": "2024-12-02T16:24:58.829112Z",
        "role": "user",
        "source": "web_client",
        "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.20;  import { IZKPayClient } from \"../../interfaces/IZKPayClient.sol\"; import { IZKPay } from \"../../interfaces/IZKPay.sol\"; import { DataTypes } from \"../../types/DataTypes.sol\"; import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";  contract AirdropClient is IZKPayClient {     using SafeERC20 for IERC20;      event LogError(uint8 errorCode, string errorMessage);      address public _owner;     address public _zkpay;     IERC20 public immutable _token;     uint256 public constant AIRDROP_AMOUNT = 150 * 10 ** 18; // 150 tokens with 18 decimals     bool public _airdropExecuted;     bytes32 public _queryHash;      constructor(address zkpay, address demoToken) {         _owner = msg.sender;         _zkpay = zkpay;         _token = IERC20(demoToken);         _airdropExecuted = false;     }      modifier onlyOwner() {         require(msg.sender == _owner, \"Caller is not the owner\");         _;     }      modifier onlyZKPay() {         require(msg.sender == _zkpay, \"Caller is not _zkpay\");         _;     }      modifier onlyOnce() {         require(!_airdropExecuted, \"Airdrop has already been executed\");         _;         _airdropExecuted = true;     }      function queryZKPay() external payable onlyOwner {         DataTypes.QueryParameter[] memory queryParams;          DataTypes.QueryData memory queryData = DataTypes.QueryData({             query: abi.encode(                 \"SELECT FROM_ADDRESS, COUNT(*) AS TRANSACTION_COUNT FROM ETHEREUM.TRANSACTIONS WHERE TO_ADDRESS = '0xae7ab96520de3a18e5e111b5eaab095312d7fe84' AND FROM_ADDRESS != '0x0000000000000000000000000000000000000000' GROUP BY FROM_ADDRESS ORDER BY TRANSACTION_COUNT DESC LIMIT 400;\"             ),             queryType: DataTypes.QueryType.SQL,             queryParameters: queryParams,             timeout: uint64(block.timestamp + 30 minutes),             callbackClientContractAddress: address(this),             callbackGasLimit: 400_000,             callbackData: \"\",             zkVerficiation: DataTypes.ZKVerification.External         });          _queryHash = IZKPay(_zkpay).queryWithNative{ value: msg.value }(queryData);     }      function sxtCallback(         DataTypes.QueryResult calldata queryResult,         bytes calldata callbackData,         DataTypes.ZKVerification zkVerficiation     )         external         override         onlyZKPay         onlyOnce     {         require(_queryHash != 0, \"Invalid query hash\");         require(queryResult.queryHash == _queryHash, \"Query hash does not match\");          for (uint256 i = 0; i < queryResult.columns[0].values.length; i++) {             address recipient = abi.decode(queryResult.columns[0].values[i], (address));             _token.safeTransfer(recipient, AIRDROP_AMOUNT);         }     }      function sxtErrorCallback(         DataTypes.ZKpayError calldata error,         bytes calldata callbackData     )         external         override         onlyZKPay     {         emit LogError(error.code, error.message);     }      function withdraw() external onlyOwner {         (bool success,) = _owner.call{ value: address(this).balance }(\"\");         require(success, \"Failed to send Ether\");     }      function cancelQuery(bytes32 queryHash) external onlyOwner {         IZKPay(_zkpay).cancelQueryPayment(queryHash);     }      receive() external payable { } }     // SPDX-License-Identifier: MIT pragma solidity 0.8.20;  import { DataTypes } from \"./types/DataTypes.sol\";  /**  * @title ZKPayStorage  * @author Space and Time Labs  * @notice Contract used as storage of the ZKPay contract.  * @dev It defines the storage layout of the ZKPay contract.  */ contract ZKPayStorage {     address internal _treasury;     uint248 internal _latestQueryId;      mapping(address asset => DataTypes.PaymentAssetAcceptedMethod) internal _acceptedAssets;     mapping(bytes32 queryHash => DataTypes.QueryPayment) internal _queryPayments;     mapping(bytes32 QueryHash => uint248 queryId) internal _queryIdbyHash;      mapping(address => bool) internal _verifiers;     mapping(address => bool) internal _trustedRelayers; }   pragma solidity 0.8.20;  import { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\"; import { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\"; import { IZKPay } from \"./interfaces/IZKPay.sol\"; import { IZKPayClient } from \"./interfaces/IZKPayClient.sol\"; import { ZKPayStorage } from \"./ZKPayStorage.sol\"; import { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\"; import { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\"; import { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";  import { Errors } from \"./helpers/Errors.sol\"; import { AddressSetLib } from \"./helpers/AddressSetLib.sol\"; import { EncodingLogic } from \"./logic/EncodingLogic.sol\"; import { BuyComputeCreditLogic } from \"./logic/BuyComputeCreditLogic.sol\"; import { QueryPaymentLogic } from \"./logic/QueryPaymentLogic.sol\";  import { DataTypes } from \"./types/DataTypes.sol\";  /**  * @title ZKpay contract  * @author Space and Time Labs  * @notice Main point of interaction with an ZKpay protocol:  * - Users can:  *   # buy  *   # buyWithNative  *   # query  *   # queryWithErc20  *   # queryWithNative  * - Admin can:  *   # setTreasury  *   # setAcceptedAsset  *   # addVerifier  *   # removeVerifier  *   # addTrustedRelayer  *   # removeTrustedRelayer  * - Oracle  *   # fulfillQuery  */ contract ZKPay is     Initializable,     ZKPayStorage,     IZKPay,     OwnableUpgradeable,     EIP712Upgradeable,     ReentrancyGuardUpgradeable {     using AddressSetLib for mapping(address => bool);     using SafeERC20 for IERC20;      /*///////////////////////////////////////////////////////////////////////                                     Initializers                                      ///////////////////////////////////////////////////////////////////////*/      /// @custom:oz-upgrades-unsafe-allow constructor     constructor() {         _disableInitializers();     }      /// @notice Initializes the contract, setting up the owner.     function initialize(address admin, address treasury) external initializer {         OwnableUpgradeable.__Ownable_init(admin);         __EIP712_init(\"SxT_Verifier\", \"1\");         _setTreasury(treasury);     }      function _setTreasury(address newTreasury) internal {         if (newTreasury == address(0)) {             revert Errors.InvalidAddress();         }         _treasury = newTreasury;         emit TreasurySet(newTreasury);     }      /**      * @dev Internal function for handling query submissions.      * @param queryData The struct containing the query details, including query string, parameters, and callback      * information.      * @return queryHash unique `bytes32` query hash for the submitted query.      */     function _query(DataTypes.QueryData memory queryData) internal returns (bytes32) {         if (queryData.callbackClientContractAddress != msg.sender) {             revert Errors.CallbackClientAddressShouldBeMsgSender();         }          _latestQueryId += 1;          bytes32 queryHash = EncodingLogic.generateQueryHash(_latestQueryId, queryData);          _queryIdbyHash[queryHash] = _latestQueryId;          emit QueryReceived(             _latestQueryId,             msg.sender,             queryData.query,             queryData.queryType,             abi.encode(queryData.queryParameters),             queryData.timeout,             queryData.callbackClientContractAddress,             queryData.callbackGasLimit,             queryData.callbackData,             queryData.zkVerficiation,             queryHash         );          return queryHash;     }      /**      * @dev Validate the query result's signature.      * @param queryResult The query result that contains the execution data.      * @param signature The signature proving the validity of the query result.      * @return The address of the signer recovered from the signature.      */     function _validate(         DataTypes.QueryResult memory queryResult,         bytes calldata signature     )         internal         view         returns (address)     {         bytes32 queryResultHash = EncodingLogic.encodeQueryResult(queryResult);         bytes32 digest = _hashTypedDataV4(queryResultHash);          return ECDSA.recover(digest, signature);     }      function _handleError(         DataTypes.ZKpayError calldata error,         DataTypes.QueryData memory queryData,         uint248 costAmountInPaymentToken     )         internal     {         if (!isTrustedRelayer(msg.sender)) revert Errors.CallerIsNotTrustedRelayer();          QueryPaymentLogic.settleQueryPayment(             _queryPayments, _queryIdbyHash, error.queryHash, costAmountInPaymentToken, _treasury         );          IZKPayClient(queryData.callbackClientContractAddress).sxtErrorCallback(error, queryData.callbackData);          emit QueryFulfilled(error.queryHash, msg.sender);         emit QueryErrorHandled(error.queryHash, error.code, error.message);     }      /*///////////////////////////////////////////////////////////////////////                                     Public methods                                ///////////////////////////////////////////////////////////////////////*/      /**      * @notice Fallback function to prevent accidental ether transfers.      * @dev Reverts any transaction that sends ether directly to the contract.      */     receive() external payable {         revert Errors.NotSupportedMethod();     }      function setTreasury(address newTreasury) external onlyOwner {         _setTreasury(newTreasury);     }      // verifiers / relayers management methods     function addVerifier(address verifier) external onlyOwner {         _verifiers.add(verifier);         emit VerifierAdded(verifier);     }      function removeVerifier(address verifier) external onlyOwner {         _verifiers.remove(verifier);         emit VerifierRemoved(verifier);     }      function addTrustedRelayer(address relayer) external onlyOwner {         _trustedRelayers.add(relayer);         emit TrustedRelayerAdded(relayer);     }      function removeTrustedRelayer(address relayer) external onlyOwner {         _trustedRelayers.remove(relayer);         emit TrustedRelayerRemoved(relayer);     }      /// @notice Gets the treasury address.     /// @return The address of the treasury.     function getTreasury() external view returns (address) {         return _treasury;     }      /// @notice Gets the latest query ID.     /// @return The latest query ID as a uint248.     function getLatestQueryId() external view returns (uint248) {         return _latestQueryId;     }      /// @notice Gets the query payment details for a given query hash.     /// @param queryHash The hash of the query.     /// @return The `DataTypes.QueryPayment` struct containing payment details.     function getQueryPayment(bytes32 queryHash) external view returns (DataTypes.QueryPayment memory) {         return _queryPayments[queryHash];     }      /// @notice Gets the query ID associated with a given query hash.     /// @param queryHash The hash of the query.     /// @return The query ID as a uint248.     function getQueryIdByHash(bytes32 queryHash) external view returns (uint248) {         return _queryIdbyHash[queryHash];     }      /// @notice Checks if an address is a verifier.     /// @param verifier The address to check.     /// @return True if the address is a verifier, false otherwise.     function isVerifier(address verifier) public view returns (bool) {         return _verifiers[verifier];     }      /// @notice Checks if an address is a trusted relayer.     /// @param relayer The address to check.     /// @return True if the address is a trusted relayer, false otherwise.     function isTrustedRelayer(address relayer) public view returns (bool) {         return _trustedRelayers[relayer];     }      /// @notice Gets the accepted asset method for a given asset.     /// @param asset The address of the asset.     /// @return The accepted method as a `DataTypes.PaymentAssetAcceptedMethod` struct.     function getAcceptedAssetMethod(address asset)         external         view         returns (DataTypes.PaymentAssetAcceptedMethod memory)     {         return _acceptedAssets[asset];     }      function setAcceptedAsset(address asset, bool buyCredit, bool onDemandPayments) external onlyOwner {         _acceptedAssets[asset] =             DataTypes.PaymentAssetAcceptedMethod({ buyCredit: buyCredit, onDemandQuery: onDemandPayments });          emit AcceptedAssetSet(asset, buyCredit, onDemandPayments);     }      /**      * @notice Checks if an asset supports a specific payment type.      * @param assetAddress The address of the asset to check.      * @param paymentType The type of payment (0 for BuyCredit, 1 for OnDemandQuery).      * @return True if the asset supports the payment type, false otherwise.      */     function isPaymentAssetSupported(         address assetAddress,         DataTypes.PaymentType paymentType     )         external         view         returns (bool)     {         DataTypes.PaymentAssetAcceptedMethod memory method = _acceptedAssets[assetAddress];         if (paymentType == DataTypes.PaymentType.BuyCredit) {             return method.buyCredit;         } else if (paymentType == DataTypes.PaymentType.OnDemandQuery) {             return method.onDemandQuery;         }         return false;     }      /**      * @notice Allows for the buy with ERC20 tokens.      * @dev The amount must be representable as a `uint248` for SQL proof purposes.      * @param asset The address of the ERC20 token to deposit.      * @param from The address from which the ERC20 tokens are being sent.      * @param amount The amount of ERC20 tokens to deposit.      * @param onBehalfOf The address on whose behalf the deposit is made.      */     function buy(address asset, address from, uint248 amount, address onBehalfOf) external nonReentrant {         BuyComputeCreditLogic.buy(_acceptedAssets, asset, from, amount, onBehalfOf, _treasury);     }      /**      * @notice Allows for the buy compute credit with Native tokens.      * @dev The amount must be representable as a `uint248` for SQL proof purposes.      * @param onBehalfOf The address on whose behalf the deposit is made.      */     function buyWithNative(address onBehalfOf) external payable nonReentrant {         uint248 amount = uint248(msg.value);         BuyComputeCreditLogic.buyWithNative(_acceptedAssets, amount, onBehalfOf, _treasury);     }      /**      * @dev Submits a query to SxT.      * @notice This function emits a `QueryReceived` event with the query details.      * @param queryData The struct containing the query details.      * @return queryHash The unique query hash for the submitted query.      */     function query(DataTypes.QueryData memory queryData) external returns (bytes32) {         return _query(queryData);     }      /**      * @dev Submits a query to SxT with an ERC20 token deposit.      * @param asset The address of the ERC20 token to deposit.      * @param amount The amount of tokens to deposit.      * @param queryData The struct containing the query details.      * @return queryHash The unique query hash for the submitted query.      */     function queryWithERC20(         address asset,         uint248 amount,         DataTypes.QueryData memory queryData     )         external         returns (bytes32)     {         IERC20 erc20Token = IERC20(asset);         erc20Token.safeTransferFrom(msg.sender, address(this), amount);          bytes32 queryHash = _query(queryData);          _queryPayments[queryHash] = DataTypes.QueryPayment({ asset: asset, amount: amount, source: msg.sender });          emit NewQueryPayment(queryHash, asset, amount, msg.sender);         return queryHash;     }      /**      * @dev Submits a query to SxT with a native ETH deposit.      * @param queryData The struct containing the query details.      * @return queryHash The unique query hash for the submitted query.      */     function queryWithNative(DataTypes.QueryData memory queryData) external payable returns (bytes32) {         if (msg.value > type(uint248).max) revert Errors.ValueExceedsUint248Limit();          bytes32 queryHash = _query(queryData);         uint248 amount = uint248(msg.value);          _queryPayments[queryHash] = DataTypes.QueryPayment({ asset: address(0), amount: amount, source: msg.sender });          emit NewQueryPayment(queryHash, address(0), amount, msg.sender);         return queryHash;     }      /**      * @dev Cancels a payment, refunds the payment, and deletes the associated query.      * @param queryHash The unique query hash for the submitted query.      */     function cancelQueryPayment(bytes32 queryHash) external {         QueryPaymentLogic.cancelQueryPayment(_queryPayments, _queryIdbyHash, queryHash, msg.sender);     }      /**      * @dev Sends the results of a query back to the callback contract.      * @param queryId The unique identifier for the submitted query.      * @param queryData The struct containing the query details.      * @param queryResult The result of the query.      * @param verificationSignature A signature from a verifier proving the result's validity.      * @param costAmountInPaymentToken the query cost for in the token client used to pay.      * @param prover The prover generating the proofs.      * @param error An error struct containing a code and message.      */     function fulfillQuery(         uint248 queryId,         DataTypes.QueryData memory queryData,         DataTypes.QueryResult memory queryResult,         bytes calldata verificationSignature,         uint248 costAmountInPaymentToken,         address prover,         DataTypes.ZKpayError calldata error     )         external     {         if (block.timestamp > queryData.timeout && queryData.timeout != 0) {             revert Errors.QueryTimeout();         }          if (_latestQueryId < queryId) revert Errors.InvalidQueryID();          bytes32 queryHash = EncodingLogic.generateQueryHash(queryId, queryData);          if (_queryIdbyHash[queryHash] != queryId) revert Errors.InvalidQueryHashOrID();          if (error.code != 0) {             _handleError(error, queryData, costAmountInPaymentToken);             return;         }          if (queryData.zkVerficiation == DataTypes.ZKVerification.External) {             if (verificationSignature.length == 0) {                 revert Errors.VerificationSignatureRequired();             }              address signer = _validate(queryResult, verificationSignature);             if (!isVerifier(signer)) revert Errors.InvalidVerificationSignature();         } else if (queryData.zkVerficiation == DataTypes.ZKVerification.None) {             if (!isTrustedRelayer(msg.sender)) {                 revert Errors.CallerIsNotTrustedRelayer();             }         }          QueryPaymentLogic.settleQueryPayment(             _queryPayments, _queryIdbyHash, queryHash, costAmountInPaymentToken, _treasury         );          IZKPayClient(queryData.callbackClientContractAddress).sxtCallback(             queryResult, queryData.callbackData, queryData.zkVerficiation         );          emit QueryFulfilled(queryHash, prover);     } }  // SPDX-License-Identifier: MIT pragma solidity 0.8.20;  library DataTypes {     /**      * @notice Specifies the type of payment being made.      * @dev Used to distinguish between credit purchases and on-demand query payments.      */     enum PaymentType {         BuyCredit,         OnDemandQuery     }      /**      * @notice Defines methods for accepted asset types within the ZKpay protocol.      * @dev Indicates whether an asset can be used for buying compute credits or for on-demand queries.      */     struct PaymentAssetAcceptedMethod {         /// @notice Whether the asset can be used to buy credits.         bool buyCredit;         /// @notice  Whether the asset supports on-demand query payments.         bool onDemandQuery;     }      /*      *   Enumeration representing the list of supported types by ZKpay     */     enum SolidityType {         Int256,         Uint256,         Address,         Bytes,         String     }      enum QueryType {         SQL,         SavedSQLQueryJobId,         AST     }      enum ZKVerification {         External, // off-chain verifier         None // non-zk proven             /* TBD                 * Any                 * ChainlinkFunction,                 * Evm,                  */     }      /**      *  Struct representing the result of a query.      */     struct QueryResult {         /// @notice The hash of the query.         bytes32 queryHash;         /// @notice The timestamp when the query was executed.         uint64 executionTimestamp;         /// @notice The columns of the query result.         Column[] columns;     }      /**      * Struct representing a column in a query result.      */     struct Column {         /// @notice The name of the column.         string name;         /// @notice The Solidity type of the column.         SolidityType solidityType;         /// @notice The values of the column.         bytes[] values;     }      /**      * @dev Struct representing a parameter for a query.      */     struct QueryParameter {         /// @notice The Solidity type of the parameter.         SolidityType solidityType;         /// @notice The value of the parameter.         bytes value;     }      /**      * @dev Struct containing details for a query.      */     struct QueryData {         /// @notice The content of the query.         bytes query;         /// @notice ZKpay query type. e.g., SQL.         QueryType queryType;         /// @notice The query related parameters.         QueryParameter[] queryParameters;         /// @notice The timeout in block timestamp after which the query is considered expired.         uint64 timeout;         /// @notice The address of the contract to callback with the result.         address callbackClientContractAddress;         /// @notice The maximum amount of gas to use for the callback.         uint64 callbackGasLimit;         /// @notice Extra data to be passed back in the callback.         bytes callbackData;         /// @notice Indicates the results verification method         ZKVerification zkVerficiation;     }      /**      * @dev Struct representing a payment for a query.      */     struct QueryPayment {         /// @notice The address of the token used for payment.         address asset;         /// @notice The amount of tokens paid.         uint248 amount;         /// @notice The source address of the payment.         address source;     }      /**      * @dev Struct representing an error from ZKpay.      */     struct ZKpayError {         /// @notice The hash of the query.         bytes32 queryHash;         /// @notice The error code.         uint8 code;         /// @notice The error message.         string message;     } }   // SPDX-License-Identifier: MIT pragma solidity 0.8.20;  import { DataTypes } from \"../types/DataTypes.sol\";  /// @title IZKPayClient - Interface for ZKpay client contract callbacks /// @notice Client contracts implement this interface to utilize the ZKpay protocol. The methods defined here are /// callbacks that are required by the protocol to handle query results and error handling. interface IZKPayClient {     /**      * @notice Callback function for handling successful query results.      * @dev This function is invoked by the ZKpay contract upon successful fulfillment of a query.      * @param queryResult The struct containing the results of the query.      * @param callbackData Additional data that was originally passed with the query.      * @param zKVerification The zero-knowledge verification method used.      */     function sxtCallback(         DataTypes.QueryResult calldata queryResult,         bytes calldata callbackData,         DataTypes.ZKVerification zKVerification     )         external;      /**      * @notice Callback function for handling errors in the query process.      * @dev This function is invoked by the ZKpay contract if the request is faulty.      * @param error The struct containing details of the error, including an error code and message.      * @param callbackData Additional data that was originally passed with the query.      */     function sxtErrorCallback(DataTypes.ZKpayError calldata error, bytes calldata callbackData) external; }   // SPDX-License-Identifier: MIT pragma solidity 0.8.20;  import { DataTypes } from \"../types/DataTypes.sol\";  /// @title IZKPay - Interface for the ZKPay contract /// @notice Defines the primary interaction methods and events for users, admin, and results oracles. interface IZKPay {     /*///////////////////////////////////////////////////////////////////////                                  Events     ///////////////////////////////////////////////////////////////////////*/      /// @notice Emitted when the treasury address is updated by the admin.     /// @param newTreasury The new treasury address set for the protocol.     event TreasurySet(address indexed newTreasury);      /// @notice Emitted when a verifier is added by the admin.     /// @param verifier The address of the newly added verifier.     event VerifierAdded(address indexed verifier);      /// @notice Emitted when a verifier is removed by the admin.     /// @param verifier The address of the verifier that was removed.     event VerifierRemoved(address indexed verifier);      /// @notice Emitted when a trusted relayer is added by the admin.     /// @param relayer The address of the newly added trusted relayer.     event TrustedRelayerAdded(address indexed relayer);      /// @notice Emitted when a trusted relayer is removed by the admin.     /// @param relayer The address of the trusted relayer that was removed.     event TrustedRelayerRemoved(address indexed relayer);      /// @notice Emitted when a new accepted asset is set by the admin.     /// @param asset The address of the accepted asset.     /// @param buyCredit Whether the asset is accepted for buying SXT compute credit.     /// @param onDemandPayments Whether the asset is accepted for on-demand payments.     event AcceptedAssetSet(address indexed asset, bool buyCredit, bool onDemandPayments);      /// @notice Emitted when a new query payment is made.     /// @param queryHash The unique hash of the query.     /// @param asset The address of the payment token (or zero address for native currency).     /// @param amount The amount paid for the query.     /// @param source The address that made the payment.     event NewQueryPayment(bytes32 indexed queryHash, address indexed asset, uint248 amount, address indexed source);      /// @notice Emitted when a query is fulfilled.     /// @param queryHash The unique hash of the fulfilled query.     /// @param prover The prover generating the proofs for the query.     event QueryFulfilled(bytes32 indexed queryHash, address indexed prover);      /// @notice Emitted when a new query is submitted.     /// @param queryId The unique identifier for the query.     /// @param sender The address that submitted the query.     /// @param query The query data encoded as bytes.     /// @param queryType The type of query being executed.     /// @param queryParamsblob Encoded parameters for the query.     /// @param timeout The timeout for the query in seconds.     /// @param callbackClientContractAddress The contract address to which results will be sent.     /// @param callbackGasLimit The gas limit for the callback.     /// @param callbackData Additional callback data.     /// @param zkVerification The zero-knowledge verification method.     /// @param queryHash The unique hash representing the query.     event QueryReceived(         uint248 indexed queryId,         address indexed sender,         bytes query,         DataTypes.QueryType queryType,         bytes queryParamsblob,         uint64 timeout,         address callbackClientContractAddress,         uint64 callbackGasLimit,         bytes callbackData,         DataTypes.ZKVerification zkVerification,         bytes32 queryHash     );      /// @notice Emitted when an error is handled for a query.     /// @param queryHash The hash of the query with an error.     /// @param code The error code.     /// @param message The error message providing details.     event QueryErrorHandled(bytes32 indexed queryHash, uint8 code, string message);      /*///////////////////////////////////////////////////////////////////////                                  Methods     ///////////////////////////////////////////////////////////////////////*/      /// @notice Set a new treasury address for the protocol.     /// @param newTreasury The address to be set as the new treasury.     function setTreasury(address newTreasury) external;      /// @notice Add a new verifier to the protocol.     /// @param verifier The address of the verifier to add.     function addVerifier(address verifier) external;      /// @notice Remove a verifier from the protocol.     /// @param verifier The address of the verifier to remove.     function removeVerifier(address verifier) external;      /// @notice Add a trusted relayer to the protocol.     /// @param relayer The address of the relayer to add.     function addTrustedRelayer(address relayer) external;      /// @notice Remove a trusted relayer from the protocol.     /// @param relayer The address of the relayer to remove.     function removeTrustedRelayer(address relayer) external;      /// @notice Retrieve the current treasury address.     /// @return The current treasury address.     function getTreasury() external view returns (address);      /// @notice Retrieve the latest query ID.     /// @return The latest query ID.     function getLatestQueryId() external view returns (uint248);      /// @notice Retrieve details of a query payment by query hash.     /// @param queryHash The hash of the query.     /// @return A struct containing the details of the query payment.     function getQueryPayment(bytes32 queryHash) external view returns (DataTypes.QueryPayment memory);      /// @notice Retrieve the query ID associated with a query hash.     /// @param queryHash The hash of the query.     /// @return The query ID.     function getQueryIdByHash(bytes32 queryHash) external view returns (uint248);      /// @notice Check if an address is a verifier.     /// @param verifier The address to check.     /// @return True if the address is a verifier, false otherwise.     function isVerifier(address verifier) external view returns (bool);      /// @notice Check if an address is a trusted relayer.     /// @param relayer The address to check.     /// @return True if the address is a trusted relayer, false otherwise.     function isTrustedRelayer(address relayer) external view returns (bool);      /// @notice Retrieve the accepted asset method for a given asset.     /// @param asset The address of the asset.     /// @return The accepted asset method struct indicating if it can be used for deposits and on-demand payments.     function getAcceptedAssetMethod(address asset)         external         view         returns (DataTypes.PaymentAssetAcceptedMethod memory);      /// @notice Set an asset as accepted for credit purchases and/or on-demand payments.     /// @param asset The address of the asset.     /// @param buyCredit Whether the asset can be used for credit purchases.     /// @param onDemandPayments Whether the asset can be used for on-demand payments.     function setAcceptedAsset(address asset, bool buyCredit, bool onDemandPayments) external;      /// @notice Check if an asset supports a specified payment type.     /// @param assetAddress The address of the asset.     /// @param paymentType The type of payment to check (e.g., BuyCredit or OnDemandQuery).     /// @return True if the asset supports the specified payment type, false otherwise.     function isPaymentAssetSupported(         address assetAddress,         DataTypes.PaymentType paymentType     )         external         view         returns (bool);      /// @notice Make a payment to buy compute credits using ERC20 tokens.     /// @param asset The ERC20 token address used for payment.     /// @param from The address sending the tokens.     /// @param amount The amount of tokens to transfer.     /// @param onBehalfOf The address on whose behalf the purchase is made.     function buy(address asset, address from, uint248 amount, address onBehalfOf) external;      /// @notice Make a payment to buy compute credits using native tokens.     /// @param onBehalfOf The address on whose behalf the purchase is made.     function buyWithNative(address onBehalfOf) external payable;      /// @notice Submit a query to the protocol.     /// @param queryData The struct containing query details.     /// @return The unique hash representing the query.     function query(DataTypes.QueryData memory queryData) external returns (bytes32);      /// @notice Submit a query with a payment in ERC20 tokens.     /// @param asset The ERC20 token used for the payment.     /// @param amount The amount of tokens to deposit.     /// @param queryData The struct containing the query details.     /// @return The unique hash representing the query.     function queryWithERC20(         address asset,         uint248 amount,         DataTypes.QueryData memory queryData     )         external         returns (bytes32);      /// @notice Submit a query with a payment in native tokens.     /// @param queryData The struct containing the query details.     /// @return The unique hash representing the query.     function queryWithNative(DataTypes.QueryData memory queryData) external payable returns (bytes32);      /// @notice Cancel a query payment, refunding the original payment and removing the query.     /// @param queryHash The hash of the query to be canceled.     function cancelQueryPayment(bytes32 queryHash) external;      /// @notice Fulfill a query by providing results, a signature is required if results requested to be ZK proven.     /// @param queryId The unique ID of the query.     /// @param queryData The struct containing query details.     /// @param queryResult The struct containing query results.     /// @param verificationSignature Signature from a verifier proving validity.     /// @param costAmountInPaymentToken The cost associated with fulfilling the query.     /// @param prover The prover address providing the proof.     /// @param error An error struct containing code and message (if any error occurs).     function fulfillQuery(         uint248 queryId,         DataTypes.QueryData memory queryData,         DataTypes.QueryResult memory queryResult,         bytes calldata verificationSignature,         uint248 costAmountInPaymentToken,         address prover,         DataTypes.ZKpayError calldata error     )         external; }",
        "metadata": {}
    }
]